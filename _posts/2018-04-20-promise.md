---
layout:     post
title:      "Promise"
date:       2018-04-17
author:     "Kerwin She"
header-img: "img/post-bg-js-version.jpg"
tags:
    - ES6
---
> 摘抄自阮老师[ES6入门][1]

## 1.Promise含义

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
Promise对象有以下两个特点：
 - 对象的状态不受外界影响,Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
 - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。

Promise对象缺点：

 - 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。
 - 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
 - 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

## 2.基本用法

ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。
下面代码创造了一个`Promise`实例。

```javascript
const promise = new Promise(function(resolve, reject) {
 // ... some code
 if (/* 异步操作成功 */){
   resolve(value); //从“未完成”变为“成功”（即从 pending 变为 resolved）
 } else {
   reject(error);//从“未完成”变为“失败”（即从 pending 变为 rejected）
 }
});
```
> **注意**: Promise对象一旦创建，就会立即执行所传进去的函数


`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数

```javascript  
  promise.then(function(value) {
   // success
  }, function(error) {
   // failure
  });
```
> **注意** :
 -  `then`函数的第二个参数是可选的，
 - `value`参数是 `Promise`实例的`reslove`传过来的，`error`则是`reject`


## 3.**执行顺序**
 ```javascript
  let promise = new Promise(function(resolve, reject) {
     console.log('Promise');
     resolve();
     console.log('hello')
  });
  promise.then(function() {
   console.log('resolved.');
  });
  console.log('Hi!');
  // Promise
  // hello
  // Hi!
  // resolved
 ```

> **注意**
 - `Promise` 新建后会立即执行 :所以先输出 Promise
 - `then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行 ： 所以最后输出resolved
 - `resolve`或`reject`并不会终结 Promise 的参数函数的执行: 所以hello依旧能输出


## 4.`reslove`和`reject`的参数

 如果调用`resolve`函数和`reject`函数时带有参数，那么它们的参数会被传递给回调函数.

 ### `reject`

 `reject`函数的参数通常是`Error`对象的实例，表示抛出的错误

### `resolve`

` resolve`函数的参数除了正常的值以外，还可能是另一个 `Promise` 实例，比如像下面这样
 ```javascript
  const p1 = new Promise(function (resolve, reject) {
   // ...
  });

  const p2 = new Promise(function (resolve, reject) {
   // ...
   resolve(p1);
  })
 ```
 上面代码中，`p1`和`p2`都是 `Promise` 的实例，但是`p2`的`resolve`方法将`p1`作为参数，即一个异步操作的结果是返回另一个异步操作。

 > **注意**:
  `p1`的状态决定了`p2`的状态,所以`p1`状态为`resolved`或是`rejected`时，`p2`的回调函数才会执行

 例子：
```javascript
  const p1 = new Promise(function (resolve, reject) {
   setTimeout(() => reject(new Error('fail')), 3000)
  })

  const p2 = new Promise(function (resolve, reject) {
   setTimeout(() => resolve(p1), 1000)
  })

  p2
   .then(result => console.log(result))
   .catch(error => console.log(error))
  // Error: fail
```
上面代码中，`p1`是一个 `Promise`，3 秒之后变为`rejected`。p2的状态在 1 秒之后改变，`resolve`方法返回的是`p1`。由于`p2`返回的是另一个 `Promise`，导致`p2`自己的状态无效了，由`p1`的状态决定`p2`的状态。所以，后面的`then`语句都变成针对后者（`p1`）。又过了 2 秒，p1变为`rejected`，导致触发`catch`方法指定的回调函数。

## 5.Promise.prototype.then()

`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。
```javascript
getJSON("/posts.json").then(function(json) {
 return json.post;
}).then(function(post) {
 // ...
});
```
采用链式的`then`，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。

```javascript
getJSON("/post/1.json").then(function(post) {
 return getJSON(post.commentURL);
}).then(function funcA(comments) {
 console.log("resolved: ", comments);
}, function funcB(err){
 console.log("rejected: ", err);
});
```
> **注意** ：  `then`方法之所以支持链式调用是因为其默认创建了新的`Promise`实例返回。

## 6.Promise.prototype.catch()

`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。

`Promise.prototype.catch`方法可以捕获状态为`rejected`，也可以捕获错误对象 `Error`
```javascript
const promise = new Promise(function(resolve, reject) {
 reject('test')
});
promise.catch(function(error) {
 console.log(error);
});
// Error: test
```
```javascript
const promise = new Promise(function(resolve, reject) {
 throw new Error('test');
});
promise.catch(function(error) {
 console.log(error);
});
// Error: test
```
如果 `Promise` 状态已经变成`resolved`，再抛出错误是无效的
```javascript
const promise = new Promise(function(resolve, reject) {
 resolve('ok');
 throw new Error('test');
});
promise
 .then(function(value) { console.log(value) })
 .catch(function(error) { console.log(error) });
// ok
```
`Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。
```javascript
getJSON('/post/1.json').then(function(post) {
 return getJSON(post.commentURL);
}).then(function(comments) {
 // some code
}).catch(function(error) {
 // 处理前面三个Promise产生的错误
});
```
一般来说，不要在`then`方法里面定义 `Reject` 状态的回调函数（即then的第二个参数），总是使用`catch`方法。
`catch`方法返回的还是一个 `Promise` 对象，因此后面还可以接着调用`then`方法。
## 7.Promise.prototype.finally()
`finally`方法用于指定不管 `Promise` 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的

## 8.Promise.all()
`Promise.all`方法用于将多个 `Promise` 实例，包装成一个新的 `Promise` 实例。
```javascript
 const p = Promise.all([p1, p2, p3]);
```

## 9.Promise.race()
`Promise.race`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
```javascript
 const p = Promise.race([p1, p2, p3]);
```
上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数


## 10.Promise.resolve()
有时需要将现有对象转为 `Promise` 对象，`Promise.resolve`方法就起到这个作用。
```javascript
 const jsPromise = Promise.resolve($.ajax('/whatever.json'));
```
上面代码将 `jQuery` 生成的`deferred`对象，转为一个新的 `Promise` 对象。
`Promise.resolve`等价于下面的写法。
```javascript
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```
## Promise.reject()
`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。

**推荐**

[BlueBird][2] ： 让所有浏览器都支持 ES6 Promise 对象

[1]:http://es6.ruanyifeng.com/?search=%E5%89%8D%E8%A8%80&x=7&y=7#docs/promise
[2]:https://github.com/petkaantonov/bluebird
