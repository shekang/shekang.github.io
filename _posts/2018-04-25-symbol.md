---
layout:     post
title:      "Symbol"
date:       2018-04-25
author:     "Kerwin She"
header-img: "img/post-bg-js-version.jpg"
tags:
    - ES6
---

## 概述
 ES5 的**对象属性名**都是**字符串**，这容易造成属性名的冲突，如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 `ES6` 引入`Symbol`的原因。

 `Symbol`是表示独一无二的值，它是 `JavaScript` 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（`Boolean`）、字符串（`String`）、数值（`Number`）、对象（Object）。

### 基础注意点
 1.  对象属性名现在可以有两种类型
   - 一种是原来就有的字符串
   - 另一种就是新增的 Symbol 类型。
 2.  Symbol通过 `Symbol`函数生成，
 ```javascript
 let s = Symbol()
 typeof s
 // "symbol"
 ```
 > 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。注意：`Symbol`函数前不能使用`new`命令,它是一种**类似于字符串的数据类型**。

 3. `Symbol`函数可以接受一个字符串作为参数，表示对 `Symbol` 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
 ```javascript
   let s1 = Symbol('foo');
   let s2 = Symbol('bar');

   s1 // Symbol(foo)
   s2 // Symbol(bar)

   s1.toString() // "Symbol(foo)"
   s2.toString() // "Symbol(bar)"
 ```
 4. 如果 `Symbol` 的参数是一个对象，就会调用该对象的`toString`方法，将其转为字符串，然后才生成一个 `Symbol` 值。
 ```javascript
  const obj = {
    toString() {
      return 'abc';
    }
  };
  const sym = Symbol(obj);
  sym // Symbol(abc)
 ```
 5. `Symbol`函数的参数只是表示对当前 `Symbol` 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的。
 ```javascript
   // 没有参数的情况
  let s1 = Symbol();
  let s2 = Symbol();

  s1 === s2 // false

  // 有参数的情况
  let s1 = Symbol('foo');
  let s2 = Symbol('foo');

  s1 === s2 // false
 ```
 6. Symbol 值不能与其他类型的值进行运算
 7. Symbol 值可以显式转为字符串,Symbol 值也可以转为布尔值，但是不能转为数值。
 ```javascript
 let sym = Symbol('My symbol');
 String(sym) // 'Symbol(My symbol)'
 sym.toString() // 'Symbol(My symbol)'

 ```

## 作为属性名的Symbol
  由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。
```javascript
  let mySymbol = Symbol();
  // 第一种写法
  let a = {};
  a[mySymbol] = 'Hello!';

  // 第二种写法
  let a = {
   [mySymbol]: 'Hello!'
  };

  // 第三种写法
  let a = {};
  Object.defineProperty(a, mySymbol, { value: 'Hello!' });

  // 以上写法都得到同样结果
  a[mySymbol] // "Hello!"
```
### 注意点
 1. Symbol 值作为对象属性名时，不能用点运算符。不管赋值和取值的时候都需要加方括号
 ```javascript
  const mySymbol = Symbol();
  const a = {};
  a.mySymbol = 'Hello!';
  a[mySymbol] // undefined
  a['mySymbol'] // "Hello!"
 ```
 2. Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。
 ```javascript
  log.levels = {
   DEBUG: Symbol('debug'),
   INFO: Symbol('info'),
   WARN: Symbol('warn')
  };
  log(log.levels.DEBUG, 'debug message');
  log(log.levels.INFO, 'info message');
 ```

##  属性名的遍历
 Symbol 作为属性名，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有 `Symbol` 属性名。
 `Object.getOwnPropertySymbols`方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
```javascript
 const obj = {};
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'Hello';
obj[b] = 'World';

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols
// [Symbol(a), Symbol(b)]
 ```
 下面是另一个例子，`Object.getOwnPropertySymbols`方法与`for...in`循环`、Object.getOwnPropertyNames`方法进行对比的例子。
 ```javascript
 const obj = {};

let foo = Symbol("foo");

Object.defineProperty(obj, foo, {
 value: "foobar",
});

for (let i in obj) {
 console.log(i); // 无输出
}

Object.getOwnPropertyNames(obj)
// []

Object.getOwnPropertySymbols(obj)
// [Symbol(foo)]
 ```
 另一个新的 API，`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。
 ```javascript
 let obj = {
  [Symbol('my_key')]: 1,
  enum: 2,
  nonEnum: 3
};

Reflect.ownKeys(obj)
//  ["enum", "nonEnum", Symbol(my_key)]
 ```
## Symbol.for() 和 Symbol.keyfor()

有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
```javascript
let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');

s1 === s2 // true
```
`Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，**前者会被登记在全局环境中供搜索**，后者不会。
`Symbol.keyFor`方法返回一个已登记的 `Symbol` 类型值的`key`。
```javascript
let s1 = Symbol.for("foo");
Symbol.keyFor(s1) // "foo"

let s2 = Symbol("foo");
Symbol.keyFor(s2) // undefined
```
上面代码中，变量`s2`属于未登记的 `Symbol` 值，所以返回`undefined`。
需要注意的是，`Symbol.for`为 `Symbol` 值登记的名字，是**全局环境**的，可以在不同的 `iframe` 或 `service worker` 中取到同一个值。

## 内置Symbol值

### Symbol.hasInstance
对象的`Symbol.hasInstance`属性，指向一个内部方法。当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用这个方法。比如，`foo instanceof Foo`在语言内部，实际调用的是`Foo[Symbol.hasInstance](foo)`。
```javascript
class MyClass {
 [Symbol.hasInstance](foo) {
   return foo instanceof Array;
 }
}

[1, 2, 3] instanceof new MyClass() // true
```
上面代码中，`MyClass`是一个类，`new MyClass()`会返回一个实例。该实例的`Symbol.hasInstance`方法，会在进行`instanceof`运算时自动调用，判断左侧的运算子是否为`Array`的实例。

### Symbol.isConcatSpreadable

对象的`Symbol.isConcatSpreadable`属性等于一个布尔值，表示该对象用于`Array.prototype.concat()`时，是否可以展开。
```javascript
let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
```

### Symbol.species
对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。

### Symbol.match
对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。

### Symbol.replace
对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。

### Symbol.search
对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。

### Symbol.split
对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。

### Symbol.iterator
对象的Symbol.iterator属性，指向该对象的默认遍历器方法。

### Symbol.toPrimitive
对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。

### Symbol.toStringTag
对象的`Symbol.toStringTag`属性，指向一个方法。在该对象上面调用`Object.prototype.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制`[object Object]`或`[object Array]`中`object`后面的那个字符串。

### Symbol.unscopables
对象的`Symbol.unscopables`属性，指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。
